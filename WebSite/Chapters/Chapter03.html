---
Created by: Chris Barbour 2014
---
<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="GekoOS : The Geko Operating System" />

    <link rel="stylesheet" type="text/css" media="screen" href="../stylesheets/stylesheet.css">

    <title>GekoOS - Chapter 3</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/bobjamin/GekoOS">View on GitHub</a>

          <h1 id="project_title">GekoOS</h1>
          <h2 id="project_tagline">Chapter 03 - Disk Access</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/bobjamin/GekoOS/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/bobjamin/GekoOS/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">

        <H1>Where We Are</H1>
          
          <P>
            At present we have a single file building that represents our floppy disk image. This file is 512 bytes in size and is our boot sector. All it does is print a character or a string of characters to the text mode screen. Not a lot. This is what the floppy disk image looks like:
          </P>

          <TABLE class='byte_table'>
            <TR>
              <TH>Byte Position:</TH>
              <TH>0</TH>
              <TH></TH>
              <TH>0x200</TH>
            </TR>
            
            <TR>
              <TD></TD>
              <TD colspan="2">BootSector</TD>
              <TD></TD>
            </TR>
          </TABLE>

          <P>
            This is what memory looks like after the BIOS loads the boot sector:
          </P>

          <TABLE class='byte_table'>
            <TR>
              <TH>Byte Position:</TH>
              <TH>0</TH>
              <TH></TH>
              <TH>0x7C00</TH>
              <TH></TH>
              <TH>0x7E00</TH>
            </TR>

            <TR>
              <TD></TD>
              <TD colspan="2">IVT etc.</TD>
              <TD colspan="2">BootSector</TD>
              <TD></TD>
            </TR>
          </TABLE>

          <P>
            Everything seems good, but there's one problem. We are limited to 512 bytes of code for the operating system. Thats not nearly enough. There needs to be a way of loading more bytes of code into memory
          </P>

        <H1>Boot Loader</H1>
          <P>
            A solution to this problem is called a 2-stage boot loader. The first stage is the boot sector whos only job is to load a second stage called the boot loader. The boot loader will be responsible for ultimately loading the kernel.
          </P>

          <P>
            Our boot sector will have only one role. That is to load the boot loader. To begin creating this we need to understand how to read data from the disk and load it into memory.
          </P>
          
          <P>
            Once loaded the above floppy image will become: 
          </P>
 
          <TABLE class='byte_table'>
            <TR>
              <TH>Byte Position:</TH>
              <TH>0</TH>
              <TH></TH>
              <TH>0x200</TH>
              <TH></TH>
              <TH>0x200 + size of bootloader</TH>

            </TR>

            <TR>
              <TD></TD>
              <TD colspan="2">BootSector</TD>
              <TD colspan="2">BootLoader</TD>
              <TD></TD>
            </TR>
          </TABLE>

          <P>
            This is what memory will look like after the BIOS loads the boot sector and the boot sector loads the boot loader. We will need to use the stack, which grows downward in memory so we can place it at 0x8000 to give it enough room.
          </P>

          <TABLE class='byte_table'>
            <TR>
              <TH>Byte Position:</TH>
              <TH>0</TH>
              <TH></TH>
              <TH>0x7C00</TH>
              <TH></TH>
              <TH>0x7E00</TH>
              <TH></TH>
              <TH>0x8000</TH>
              <TH></TH>
              <TH>0x9000</TH>
              <TH></TH>
              <TH>0x9000 + bl size</TH>
            </TR>

            <TR>
              <TD></TD>
              <TD colspan="2">IVT etc.</TD>
              <TD colspan="2">BootSector</TD>
              <TD colspan="2">Stack</TD>
              <TD colspan="2">***</TD>
              <TD colspan="2">BootLoader</TD>
              <TD></TD>
            </TR>
          </TABLE>

        <H1>Disk Access</H1>

          <P>
            Once again the BIOS has done us a favour and provided us with an interrupt for disk access, <SPAN class='icode'>Int 0x13</SPAN>. It is important to note that when the BIOS loads the boot device (floppy disk) it stores a number associated with this device in the <SPAN class='icode'>DL</SPAN> register.
          </P>

          <H3>Int 0x13</H3>
              <P>
                Interrupt 0x13 is the interrupt associated with disk access. The first function we will look at is the read function. The read function reads from the device and places the bytes it loads into memory.
              </P>

              <TABLE class="dir_table">
                <TR>
                  <TH>Register</TH>
                  <TH>Value</TH>
                  <TH>Description</TH>
                </TR>

                <TR>
                  <TD>AH</TD>
                  <TD>0X02</TD>
                  <TD>Load bytes from Disk Function</TD>
                </TR>

                <TR>
                  <TD>AL</TD>
                  <TD>Byte</TD>
                  <TD>Number of sectors to load. Sector size is device dependent. (512 bytes for floppys)</TD>
                </TR>

                <TR>
                  <TD>CH</TD>
                  <TD>Byte</TD>
                  <TD>Low 8-bits of cylinder number</TD>
                </TR>

                <TR>
                  <TD>CL bits 0-5 (<STRONG>111111</STRONG>11)</TD>
                  <TD>5 Bits</TD>
                  <TD>First Sector Number</TD>
                </TR>

                <TR>
                  <TD>CL bits 6-7 (111111<STRONG>11</STRONG>)</TD>
                  <TD>2 Bits</TD>
                  <TD>High 2-bits of Cylinder Number (HD only)</TD>
                </TR>

                <TR>
                  <TD>DH</TD>
                  <TD>Byte</TD>
                  <TD>Head Number</TD>
                </TR>

                <TR>
                  <TD>DL</TD>
                  <TD>Byte</TD>
                  <TD>
                    <TABLE class='dir_table'>
                      <TR><TD colspan='2'>Drive Number</TD></TR>
                      <TR>
                        <TH>DL</TH>
                        <TH>Drive</TH>
                      </TR>

                      <TR>
                        <TD>0X00</TD>
                        <TD>Floppy 1 (A:)</TD>
                      </TR>

                      <TR>
                        <TD>0X01</TD>
                        <TD>Floppy 2 (B:)</TD>
                      </TR>

                      <TR>
                        <TD>0X80</TD>
                        <TD>Hard Disk 1 (C:)</TD>
                      </TR>

                      <TR>
                        <TD>0X81</TD>
                        <TD>Hard Disk 2 (D:)</TD>
                      </TR>

                    </TABLE>
                  </TD>
                </TR>

                <TR>
                  <TD>ES:BX</TD>
                  <TD>Integer:Integer</TD>
                  <TD>Memory location to write to.</TD>
                </TR>

                <TR>
                  <TH colspan='3' style='text-align:center'>Returns</TH>
                </TR>

                <TR>
                  <TD>CF</TD>
                  <TD>1 OR 0</TD>
                  <TD>Carry flag is set to 1 on error.</TD>
                </TR>

                <TR>
                  <TD>AL</TD>
                  <TD>Integer</TD>
                  <TD>Number of sectors actually read. Only valid after CF is set on some BIOSs</TD>
                </TR>

                <TR>
                  <TD>AH</TD>
                  <TD>Integer</TD>
                  <TD>Status Number</TD>
                </TR>
              </TABLE>
              <BR>

          <H2>The New BootSector.asm</H2>

            <P>
              We now have enough information to write a method for accessing the disk. This Interrupt (Int 0x13) is a bit more interessting than the last as it gives us some feedback. We can use this feedback to do some error handling.
              <BR>
              Lets start by getting our BootSector back to a clean state like the following:
            </P>

<PRE><CODE>[ORG 0X7C00]
[BITS 16]
Start:

    CLI                 ;Clear interrupts
    HLT                 ;Halt Processor

%include "Print16.i"  ;Include our print file

WELCOMEMSG  DB  "--- Welcome to Geko (16-bit real mode) ---", 0

TIMES 510-($-$$) DB 0 
DW 0XAA55</CODE></PRE>
            <BR>

            <P>
              Now add in a few variables below the <SPAN class='icode'>WELCOMEMSG</SPAN> variable. The last one is set to 0 for now but it will hold the current device. We won't use the first message but we can keep it there for later.
            </P>

<PRE><CODE>WELCOMEMSG DB  "--- Welcome to Geko (16-bit real mode) ---", 0
DISKERRMSG  DB  "Disk Read Error!",0
DISKSCCMSG  DB  "Disk Read Success!", 0
BOOTDRIVE DB  0</CODE></PRE>
            <BR>

            <P>
              Next we need to add some code after the 512 byte mark so that we have something useful to load. Place the following below the special duo line, <SPAN class='icode'>DW 0XAA55</SPAN>:
            </P>

<PRE><CODE>;Code not loaded by BIOS after the 512 byte mark
MSG     DB "BLAH BLAH BLAH", 0</CODE></PRE>
            <BR>

            <P>
              Now we can write some code to read the bytes from disk. To do this we need to do a bit of thinking. If you look at the table above the AL register is used to select the number of sectors you wish to copy. However it is also used to return the number of sectors actually read. So we need to use a different register for this so that we can compare the two. We can use DH for this, however DH is also required in the read function so we need to PUSH it to the stack and POP it when we do the comparison.
              Here is my ReadSector method, place it below the HLT after the Start label.
            </P>

<PRE><CODE>;Read DH sectors to ES:BX from Drive DL
ReadSectors:
  PUSH DX
  MOV AH, 0X2     ;Read Disk Function
  MOV CH, 0       ;Cylinder 0
  MOV CL, 0X2     ;2nd Sector (512 bytes)
  MOV AL, DH      ;No. Sectors
  MOV DH, 0       ;Head 0
  INT 0X13      ;Read
  JC .DiskError   ;Error if Carry Flag set
  POP DX
  CMP AL, DH      ;Compare No. actually copied
  JNE .DiskError
RET
.DiskError:
  MOV SI, DISKERRMSG
  CALL  PrintString16
  CLI
  HLT</CODE></PRE>
            <BR>

            <P>
              Finally we can attempt the actual load. The following code shows the BootSector code after the Start label and before the ReadSectors method. It sets up the stack and stores the current device into the BOOTDRIVE variable. BIOS Places this number into DL for us. The loaded data is found at 0x9000 in memory as described above and the message that is loaded is then printed to screen.
              <BR>
              32 sectors are loaded giving us 16 Kb of free space. This should be enough for our Operating system to roam free and load a kernel.
            </P>

<PRE><CODE>Start:

  MOV [BOOTDRIVE], DL   ;Store Boot Device number
  MOV BP, 0x8000        ;Set Stack top to 0x8000
  MOV SP, BP
  XOR AX, AX            ;Set segments to 0 offset
  MOV DS, AX
  MOV ES, AX            ;Used for loaded memory location

    MOV BX, 0X9000      ;Load data here
    MOV DL, [BOOTDRIVE] ;Select the current drive
    MOV DH, 32          ;Load 32 sectors (16 Kb)
    CALL ReadSectors    ;Load into memory

    MOV SI, DISKSCCMSG  ;If we get here then success
    CALL PrintString16

    MOV SI, 0X9000      ;Print out what is at 0x9000
    CALL PrintString16  ;Should be BLAH BLAH BLAH

    CLI                 ;Clear interrupts
    HLT                 ;Halt Processor</CODE></PRE>
            <BR>

            <P>
              That is how you load data from the disk and read the data from memory. You should now see "BLAH BLAH BLAH" appear on the screen. This means everthing worked well. 
              <BR>
              The full code listing for this chapter is shown below:
            </P>
          <H2>BootSector.asm</H2>

<PRE class='largecode'><CODE>[ORG 0X7C00]
[BITS 16]
Start:

  MOV [BOOTDRIVE], DL   ;Store Boot Device number
  MOV BP, 0x8000        ;Set Stack top to 0x8000
  MOV SP, BP
  XOR AX, AX            ;Set segments to 0 offset
  MOV DS, AX
  MOV ES, AX            ;Used for loaded memory location

  MOV BX, 0X9000        ;Load data here
  MOV DL, [BOOTDRIVE]   ;Select the current drive
  MOV DH, 32            ;Load 32 sectors (16 Kb)
  CALL ReadSectors      ;Load into memory

  MOV SI, DISKSCCMSG    ;If we get here then success
  CALL PrintString16

  MOV SI, 0X9000        ;Print out what is at 0x9000
  CALL PrintString16    ;Should be BLAH BLAH BLAH

  CLI                   ;Clear interrupts
  HLT                   ;Halt Processor

;Read DH sectors to ES:BX from Drive DL
ReadSectors:
  PUSH DX
  MOV AH, 0X2     ;Read Disk Function
  MOV CH, 0       ;Cylinder 0
  MOV CL, 0X2     ;2nd Sector (512 bytes)
  MOV AL, DH      ;No. Sectors
  MOV DH, 0       ;Head 0
  INT 0X13        ;Read
  JC .DiskError   ;Error if Carry Flag set
  POP DX
  CMP AL, DH      ;Compare No. actually copied
  JNE .DiskError
RET
.DiskError:
  MOV SI, DISKERRMSG
  CALL  PrintString16
  CLI
  HLT

%include "Print16.i"  ;Include our print file

WELCOMEMSG  DB  "--- Welcome to Geko (16-bit real mode) ---", 0
DISKERRMSG  DB  "Disk Read Error!",0
DISKSCCMSG  DB  "Disk Read Success!", 0
BOOTDRIVE DB  0

TIMES 510-($-$$) DB 0 
DW 0XAA55

;Code not loaded by BIOS after the 512 byte mark
MSG     DB "BLAH BLAH BLAH", 0</CODE></PRE>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <div style='float:right;font-size:30px;color:rgb(240,240,240);'><a href="../index.html"><</a>&nbsp&nbsp<a href="./Chapter02.html">></a></div>
        <p class="copyright">GekoOS maintained by <a href="https://github.com/bobjamin">Chris Barbour</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
